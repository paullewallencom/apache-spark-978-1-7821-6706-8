// graphX-07.scala// "Basics are Discussed And A Graph Is Built"// use in spark-shell// graphX-01.scala - Create the vertext and edge lists// graphX-02.scala - Turn the lists into RDDs and then create a graph// graphX-03.scala - Structural APIs on the newly created graph// graphX-04.scala - indegrees,subgraph// graphX-05.scala - What's wrong - Solution// graphX-06.scala - Community-Affiliation-Strengths// graphX-07.scala - Algorithms & functions to create algorithms//           - A Versatile Function - aggregateMessages()//// Algorithms//val ranks = graph.pageRank(0.1).verticesranks.collect().foreach(println)val topVertices = ranks.sortBy(_._2,false).collect.foreach(println)//// Functions to Create Algorithms -  A Versatile Function - aggregateMessages()//val oldestFollower = graph.aggregateMessages[Int](edgeContext => edgeContext.sendToDst(edgeContext.srcAttr.age),//sendMsg(x,y) => math.max(x,y) //mergeMsg)oldestFollower.collect()//  How do we get the oldest followee ?val oldestFollowee = graph.aggregateMessages[Int](    edgeContext => edgeContext.sendToSrc(edgeContext.dstAttr.age),//sendMsg    (x,y) => math.max(x,y) //mergeMsg    )oldestFollowee.collect()//// #1 : What if we want the youngest follower?val youngestFollower = graph.aggregateMessages[Int](  edgeContext => edgeContext.sendToDst(edgeContext.srcAttr.age),//sendMsg  (x,y) => math.min(x,y) //mergeMsg  )youngestFollower.collect()//// #2 : What if we want the youngest of the nodes folowee ?val youngestFollowee = graph.aggregateMessages[Int](  edgeContext => edgeContext.sendToSrc(edgeContext.dstAttr.age),//sendMsg  (x,y) => math.min(x,y) //mergeMsg  )youngestFollowee.collect()//// #3 : Can we get inDegree with aggregateMessages ?var iDegree = graph.aggregateMessages[Int](edgeContext => edgeContext.sendToSrc(1),//sendMsg(x,y) => x+y //mergeMsg)iDegree.collect()graph.inDegrees.collect()////  What's Wrong ?//iDegree = graph.aggregateMessages[Int](edgeContext => edgeContext.sendToDst(1),//sendMsg(x,y) => x+y //mergeMsg)iDegree.collect()graph.inDegrees.collect()//val oDegree = graph.aggregateMessages[Int](edgeContext => edgeContext.sendToSrc(1),//sendMsg(x,y) => x+y //mergeMsg)oDegree.collect()graph.outDegrees.collect()